#pragma once

// -lrt

#include "base/sat_base.h"
#include "base/system/sat_time.h"

#include <time.h>           // timer
#include <signal.h>         // sigval

// #include <sys/time.h>
// #include <errno.h>          // errno

//----------------------------------------------------------------------

class SAT_Timer;
class SAT_TimerListener
{
    public:
        virtual void on_TimerListener_update(SAT_Timer* ATimer, double ADelta) {}
};

//----------------------------------------------------------------------
//
//
//
//----------------------------------------------------------------------

class SAT_Timer
{
    public:
        SAT_Timer(SAT_TimerListener* AListener);
        ~SAT_Timer();
    public:
        bool isRunning();
        bool start(float ms, bool oneshot=false);
        bool stop();
        void on_timer();
    private:
        static void sat_timer_callback(sigval val);
    private:
        bool                MIsInitialized  = false;
        sigevent            MSigEvent       = {};
        timer_t             MTimer          = nullptr;
        itimerspec          MTimerSpec      = {};
        std::atomic<bool>   MIsRunning      {false};
        SAT_TimerListener*  MTimerListener  = nullptr;
        double              MPrevTime       = 0.0;
};

//----------------------------------------------------------------------
//
//
//
//----------------------------------------------------------------------

/*
    On success, timer_create() returns 0, and the ID of the new timer
    is placed in *timerid.
    On failure, -1 is returned, and errno is set to indicate the error.
*/

SAT_Timer::SAT_Timer(SAT_TimerListener* AListener)
{
    MTimerListener = AListener;
    MIsRunning = false;
    MSigEvent.sigev_notify            = SIGEV_THREAD;
    MSigEvent.sigev_notify_function   = sat_timer_callback;
    MSigEvent.sigev_notify_attributes = nullptr;
    MSigEvent.sigev_value.sival_ptr   = this;//AListener;
    int res = timer_create(CLOCK_REALTIME, &MSigEvent, &MTimer);
    if (res == -1)
    {
        switch(errno)
        {
            case EAGAIN:
                SAT_PRINT("timer_create error: Temporary error during kernel allocation of timer structures.\n");
                break;
            case EINVAL:
                SAT_PRINT("timer_create error: Clock ID, sigev_notify, sigev_signo, or sigev_notify_thread_id is invalid.\n");
                break;
            case ENOMEM:
                SAT_PRINT("timer_create error: Could not allocate memory.\n");
                break;
        }
        MIsInitialized = false;
    }
    else
    {
        MIsInitialized = true;
    }
}

/*
    timer_delete() deletes the timer whose ID is given in timerid.  If
    the timer was armed at the time of this call, it is disarmed before
    being deleted.  The treatment of any pending signal generated by the
    deleted timer is unspecified.
*/

SAT_Timer::~SAT_Timer()
{
    if (MIsInitialized) timer_delete(MTimer);
}

//------------------------------
//
//------------------------------

bool SAT_Timer::isRunning()
{
    return MIsRunning;
}

/*
    On success, timer_settime() and timer_gettime() return 0.
    On error, -1 is returned, and errno is set to indicate the error.
*/

bool SAT_Timer::start(float ms, bool oneshot)
{
    if (MIsInitialized)
    {
        if (!MIsRunning)
        {
            float s = ms * 0.001f;
            float sec = floorf(s);// SAT_Trunc(s);
            float nsec = (s-sec) * 1000000000; // 1000000.0f * (sec - SAT_Fract(s));
            time_t isec = sec;
            long insec = nsec;
            //SAT_Print("s %.4f sec %.4f nsec %.4f isec %i insec %i\n",s,sec,nsec,isec,insec);
            if (oneshot)
            {
                MTimerSpec.it_interval.tv_sec   = 0;
                MTimerSpec.it_interval.tv_nsec  = 0;
            }
            else
            {
                MTimerSpec.it_interval.tv_sec   = isec;
                MTimerSpec.it_interval.tv_nsec  = insec;
            }
            MTimerSpec.it_value.tv_sec      = isec;
            MTimerSpec.it_value.tv_nsec     = insec;
            int res = timer_settime(MTimer, 0, &MTimerSpec, 0);
            if (res == -1)
            {
                switch(errno)
                {
                    case EFAULT:
                        SAT_PRINT("timer_settime error: new_value, old_value, or curr_value is not a valid pointer.\n");
                        break;
                    //case EINVAL:
                    //    SAT_Print("timer_settime error: timerid is invalid.\n");
                    //    break;
                    case EINVAL:
                        SAT_PRINT("timer_settime: new_value.it_value is negative; or new_value.it_value.tv_nsec is negative or greater than 999,999,999.\n");
                        break;
                }
                MIsRunning = false;
                return false;
            }
            MIsRunning = true;
            MPrevTime = SAT_GetTime();
            return true;
        }
        // already running        
        return true;
    }
    // error
    return false;
}

/*
    If new_value->it_value specifies a nonzero value (i.e., either sub‐
    field is nonzero), then timer_settime() arms (starts) the timer, set‐
    ting it to initially expire at the given time.  (If the timer was
    already armed, then the previous settings are overwritten.)  If
    new_value->it_value specifies a zero value (i.e., both subfields are
    zero), then the timer is disarmed.
*/

bool SAT_Timer::stop()
{
    if (MIsRunning)
    {
        MIsRunning = false;
        MTimerSpec.it_interval.tv_sec   = 0;
        MTimerSpec.it_interval.tv_nsec  = 0;
        MTimerSpec.it_value.tv_sec      = 0;
        MTimerSpec.it_value.tv_nsec     = 0;
        int res = timer_settime(MTimer, 0, &MTimerSpec, 0);
        if (res != 0)
        {
            SAT_PRINT("error stopping timer\n");
            MIsRunning = false;
        }
        return false;
    }
    return true;
}

void SAT_Timer::on_timer()
{
    double time = SAT_GetTime(); // MS();
    double delta = time - MPrevTime;
    //SAT_PRINT("delta %.3f\n",delta);
    if (MTimerListener && MIsRunning) MTimerListener->on_TimerListener_update(this,delta);
    MPrevTime = time;
}

void SAT_Timer::sat_timer_callback(sigval val)
{
    SAT_Timer* timer = (SAT_Timer*)val.sival_ptr;
    if (timer) timer->on_timer();
}
